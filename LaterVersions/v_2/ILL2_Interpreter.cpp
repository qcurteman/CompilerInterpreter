/* PROGRAM Il2_Interpreter

This program is an interpreter (evaluator) of an Il2 sentence which consists of a sequence of
P-instructions. An Il2 sentence is generated by the PROGRAM HLL1_Compiler. The result of a
successful interpretation is displayed on screen, else an error message is displayed.



*/

#include <fstream>
#include <iostream>
#include <iomanip>
#include <string>
#define codeMax 500
#define stackMax 500

using namespace std;

/*==============================================================================*/

class interpreter
{
public:
	interpreter(void); // constructor
	~interpreter() {}; // destructor not defined yet

private:
	enum opCodes { add, sub, mul, dvd, ldi, prn, prs, prc, nln, hlt, sto, inc, nul };

	struct pInstruction
	{
		opCodes op;
		int arg;
	};
	struct memoryType
	{
		pInstruction pCode[codeMax];
		int s[stackMax];
	};
	memoryType memory;

	enum progStat { running, finished, stkchk, divchk, lowchk, opchk };
	struct registerType
	{
		int pc, tos;
		progStat ps;
	};
	registerType reg;

	typedef char shortString[4];

	shortString mnemonic[nul + 1]; //HERHERHERHHERHERHEHRHERHEHERHREHR
	int hasErrors;
	ifstream codeFile;

	void getCodeFile(void);
	void initMnemonic(void);
	void skipLabel(char &ch);
	void loadCode(void);
	void dectBy(int i);
	void inctBy(int i);
	int stackOkay(void);
	void resetStack(void);
	void postMortem(void);
	void initialize(void);
	void nextStep(void);
	void interpret(void);
	string generateString(void);
}; // class interpreter

/*==================================================================*/
/*==================================================================*/

//-----------//
//CONSTRUCTOR//
//-----------//
interpreter::interpreter(void)
{
	getCodeFile();
	initMnemonic();
	loadCode();
	if (hasErrors == false) { cout << endl; interpret(); }
	//system("pause");
} // interpreter

//*******************************************************************//
//*******************************************************************//
//
//						void getCodeFile(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::getCodeFile(void)
{
	char str[20];
	cout << endl << " === Il2 Interpreter === " << endl << endl;
	cout << "This interpreter accepts an Il2 sentence and interpretes its statements." << endl
		<< "Output of an interpretation is displayed on the screen." << endl << endl;
	do
	{
		cout << "OBJ-CODE FILE : ";
		cin.getline(str, 20, '\n');
		codeFile.open(str);
	} while (!codeFile);
}

//*******************************************************************//
//*******************************************************************//
//
//						void initMnemonic(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::initMnemonic(void)
{
	strcpy_s(mnemonic[add], "ADD");
	strcpy_s(mnemonic[sub], "SUB");
	strcpy_s(mnemonic[mul], "MUL");
	strcpy_s(mnemonic[dvd], "DVD");
	strcpy_s(mnemonic[ldi], "LDI");
	strcpy_s(mnemonic[prn], "PRN");
	strcpy_s(mnemonic[prc], "PRC");
	strcpy_s(mnemonic[prs], "PRS");
	strcpy_s(mnemonic[nln], "NLN");
	strcpy_s(mnemonic[hlt], "HLT");
	strcpy_s(mnemonic[nul], "NUL");
	strcpy_s(mnemonic[sto], "STO");
	strcpy_s(mnemonic[inc], "INT");
}

/* ----------------------------------------- the Code Loader -------------------------------------------*/

//*******************************************************************//
//*******************************************************************//
//
//						void ReadLn(istream &istr)
//
//*******************************************************************//
//*******************************************************************//
void ReadLn(istream &istr)
{
	// discard current line in the stream
	char ch;
	istr.get(ch);
	while (ch != '\n') istr.get(ch);
	istr.get(ch); // eat the nwln char
}

//*******************************************************************//
//*******************************************************************//
//
//						void Eoln(istream &istr)
//
//*******************************************************************//
//*******************************************************************//
int Eoln(istream &istr)
{
	// is the rest of the line empty?
	char ch;
	while ((ch = istr.peek()) == ' ') istr.get(ch);
	if (ch == '\n')
		return true;
	else
		return false;
}

//*******************************************************************//
//*******************************************************************//
//
//						void upperCase(char &ch)
//
//*******************************************************************//
//*******************************************************************//
void upperCase(char &ch)
{
	if (ch >= 'a' && ch <= 'z') { ch = ch - 'a' + 'A'; }
}

//*******************************************************************//
//*******************************************************************//
//
//						int isLetter(char ch)
//
//*******************************************************************//
//*******************************************************************//
int isLetter(char ch)
{
	if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))
		return true;
	else
		return false;
}

//*******************************************************************//
//*******************************************************************//
//
//						void skipLabel(char &ch)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::skipLabel(char &ch)
{
	do
	{
		codeFile.get(ch);
	} while (!codeFile.eof() && isLetter(ch) == false);
}

//*******************************************************************//
//*******************************************************************//
//
//						void loadCode(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::loadCode(void)
{
	char ch = ' ';
	int nextCode = 0;
	shortString thisCode; //HELP PROFESSOR
	hasErrors = false;
	for (int i = 0; i <= codeMax; i++)
	{
		memory.pCode[i].op = nul; // fill the rest w/ invalid op-code
		memory.pCode[i].arg = 0;
	}

	do
	{
		skipLabel(ch);
		if (!codeFile.eof())
		{
			upperCase(ch);
			thisCode[0] = ch;
			for (int i = 1; i <= 2; ++i) //why ++i and not i++
			{
				codeFile.get(ch);  upperCase(ch);  thisCode[i] = ch;
			}
			thisCode[3] = '\0';

			memory.pCode[nextCode].op = add; // prepare to search op-code
			strcpy_s(mnemonic[nul], thisCode);
			while (strcmp(thisCode, mnemonic[memory.pCode[nextCode].op]) != false)
			{
				// is thisCode an invalid op-code?
				memory.pCode[nextCode].op = opCodes(memory.pCode[nextCode].op + 1);
			}
			if (memory.pCode[nextCode].op == nul)
			{
				cout << "Invalid op-code " << thisCode << " at " << nextCode << endl;
				hasErrors = true;
			}
			if (memory.pCode[nextCode].op == ldi || memory.pCode[nextCode].op == inc)
				if (Eoln(codeFile) == true)
				{
					cout << "Missing operand at instr " << nextCode << endl;
					hasErrors = true;
				}
				else
					codeFile >> memory.pCode[nextCode].arg;

			ReadLn(codeFile);
		} // if
		nextCode = (nextCode + 1) % codeMax;
	} while (!codeFile.eof());

	for (int ii = nextCode; ii <= codeMax; ii++)
	{
		memory.pCode[ii].op = nul; // fill the rest with invalid op-code
	}
} // loadCode

/* ----------------------------------------- Interpreter Engine -------------------------------------------*/

//*******************************************************************//
//*******************************************************************//
//
//						void interpret(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::interpret(void)
{
	initialize();
	do{ nextStep(); } while (reg.ps == running);
	if (reg.ps != finished) postMortem();
}

//*******************************************************************//
//*******************************************************************//
//
//						void initialize(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::initialize(void)
{
	for (int i = 0; i <= stackMax; i++)
	{
		memory.s[i] = 0; // clear stack
		resetStack();
		reg.pc = 0;
		reg.ps = running;
	}
}

//*******************************************************************//
//*******************************************************************//
//
//						void decBy(int i)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::dectBy(int i) // decrement stack pointer, check for underflow
{
	reg.tos = reg.tos - i;
	if (reg.tos < 0) reg.ps = lowchk;
}

//*******************************************************************//
//*******************************************************************//
//
//						void inctBy(int i)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::inctBy(int i) // increment stack pointer, check for overflow
{
	reg.tos = reg.tos + i;
	if (reg.tos > stackMax) reg.ps = stkchk;
}

//*******************************************************************//
//*******************************************************************//
//
//						int stackOkay(void)
//
//*******************************************************************//
//*******************************************************************//
int interpreter::stackOkay(void) // check that stack pointer has not underflowed
{
	if (reg.tos < 0) reg.ps = lowchk;
	if (reg.ps == running)
		return true;
	else
		return false;
}

//*******************************************************************//
//*******************************************************************//
//
//						void resetStack(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::resetStack(void) { reg.tos = -1; }

//*******************************************************************//
//*******************************************************************//
//
//						void postMortem(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::postMortem(void)
{
	cout << "Error: ";
	switch (reg.ps)
	{
	case stkchk: cout << "Stack overflow"; break;
	case lowchk: cout << "Stack underflow"; break;
	case divchk: cout << "Can't divide by zero"; break;
	case opchk: cout << "Invalid op-code"; break;
	}
	cout << " at instruction " << (reg.pc - 1) << "." << endl;
}

//*******************************************************************//
//*******************************************************************//
//
//						string generateString(void)
//
//*******************************************************************//
//*******************************************************************//
string interpreter::generateString(void)
{
	string returnString;
	int moveAmount = memory.s[reg.tos];
	dectBy(moveAmount);
	for (int count = 0; count < moveAmount; count++)
	{
		char appendChar = memory.s[reg.tos];
		returnString.append(1, appendChar);
		inctBy(1);
	}
	resetStack();
	return returnString;
}

//*******************************************************************//
//*******************************************************************//
//
//						void nextStep(void)
//
//*******************************************************************//
//*******************************************************************//
//Change: The algebra produces the wrong numbers????
void interpreter::nextStep(void)
{
	pInstruction i;
	i = memory.pCode[reg.pc];
	reg.pc = reg.pc + 1; // fetch next p-instruction
	switch (i.op)
	{
	case nul: reg.ps = opchk; break;
	case add: dectBy(1);
		if (reg.ps == running) memory.s[reg.tos] = memory.s[reg.tos] + memory.s[reg.tos + 1]; break;
	case sub: dectBy(1);
		if (reg.ps == running) memory.s[reg.tos] = memory.s[reg.tos] - memory.s[reg.tos + 1]; break;
	case mul: dectBy(1);
		if (reg.ps == running) memory.s[reg.tos] = memory.s[reg.tos] * memory.s[reg.tos + 1]; break;
	case dvd: dectBy(1);
		if (reg.ps == running)
			if (memory.s[reg.tos + 1] == 0) reg.ps = divchk;
			else memory.s[reg.tos] = int(memory.s[reg.tos] / memory.s[reg.tos + 1]);
			break;
	case ldi: inctBy(1);
		if (reg.ps == running) memory.s[reg.tos] = i.arg; break;
	case sto: dectBy(1);
		if (reg.ps == running) memory.s[reg.tos] = memory.s[reg.tos + 1]; break;
	case inc: inctBy(i.arg); break;
	case prn:
		if (stackOkay() == true) cout << memory.s[reg.tos];
		resetStack();
		break;
	case prs:
		if (stackOkay() == true) cout << generateString(); break;
	case prc:
		if (stackOkay() == true)
		{
			char printChar = memory.s[reg.tos];
			cout << printChar;
			resetStack();
		}
		break;
	case nln:
		inctBy(1);
		if (stackOkay() == true)
			cout << endl;
		//dectBy(1);
		break;
	case hlt: reg.ps = finished;
	}
} // nextStep

/*==============================================================================*/

void main() { interpreter myInterpreter; cin.get(); } // construct an interpreter!