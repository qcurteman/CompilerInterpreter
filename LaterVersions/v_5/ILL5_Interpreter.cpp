#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif
/* PROGRAM ILL5_Interpreter

This program is an interpreter (evaluator) of an ILL5 sentence which consists of a sequence of
P-instructions. An ILL5 sentence is generated by the PROGRAM HLL5_Compiler or HLL6_Compiler. The result of a
successful interpretation is displayed on screen, else an error message is displayed.

Let S stand for the run-time stack and TOS for the top of stack pointer. Then TopOfStack refers
to S[TOS], and AboveTop refers to S[TOS+1].

ADD   add AboveTop to TopOfStack, leave result as TopOfStack
SUB   subtract AboveTop from TopOfStack, leave result as TopOfStack
MUL   multiply AboveTop by TopOfStack, leave result as TopOfStack
DVD   integer divide TopOfStack by AboveTop, leave result as TopOfStack

(Each of the above first pops one elemnt, forms a result which is then left as TopOfStack)

NUL   empty instruction, will cause run-time error (generated by loader)
LDV   replace the top of stack by element whose address is currently TopOfStack (called dereferencing)
STO   pop the stack, store AboveTop into element whose address is given as TopOfStack, pop the stack
PRN   print TopOfStack as an integer value, pop the stack
PRC   print TopOfStack as ASCII character, pop the stack
PRS   print TopOfStack elements below top of stack, as ASCII chars, and then pop the stack by
(TopOfStack + 1) elements
NLN   print carrage-return and line-feed sequence
HLT   halt execution of p-machine
INT A push integer value A onto stack
LDA A push address value A onto stack

(A push operation first increments TOS by 1 then puts argument into stack cell.
A pop operation first grabs cell content then decrements TOS by 1.)

*/

#include <fstream>
#include <iostream>
#include <iomanip>
#include <string>
#define codeMax 500
#define stackMax 500

using namespace std;

/*==============================================================================*/

class interpreter
{
public:
	interpreter(void); // constructor
	~interpreter() {}; // destructor not defined yet

private:
	//The last code in this list MUST be 'nul'
	enum opCodes { add, sub, mul, dvd, ldi, lda, ldv, prc, prs, nln, prn, sto, inc, eql, neq, lss, leq, gtr, geq, jmp, jmz, hlt, nul };

	struct pInstruction
	{
		opCodes op;
		int arg;
	};
	struct memoryType
	{
		pInstruction pCode[codeMax];
		int s[stackMax];
	};
	memoryType memory;

	enum progStat { running, finished, stkchk, divchk, lowchk, opchk };
	struct registerType
	{
		int pc, tos;
		progStat ps;
	};
	registerType reg;

	typedef char shortString[4]; //Change: it was 3, changed it to 2 because on the paper it says "1-3" and need 1 more space for '\0'.

	shortString mnemonic[nul + 1];
	bool hasErrors;
	ifstream codeFile;

	void getCodeFile(void);
	void initMnemonic(void);
	void skipLabel(char &ch);
	void loadCode(void);
	void dectBy(int i);
	void inctBy(int i);
	bool stackOkay(void);
	void resetStack(void);
	void postMortem(void);
	void initialize(void);
	void nextStep(void);
	void interpret(void);
	string generateString(void);
}; // class interpreter

/*==================================================================*/
/*==================================================================*/

//-----------//
//CONSTRUCTOR//
//-----------//
interpreter::interpreter(void)
{
	getCodeFile();
	initMnemonic();
	loadCode();
	if (hasErrors == false) { cout << endl; interpret(); }
	//system("pause");
} // interpreter

//*******************************************************************//
//*******************************************************************//
//
//						void getCodeFile(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::getCodeFile(void)
{
	char str[20];
	cout << endl << " === ILL5 Interpreter === " << endl << endl;
	cout << "This interpreter accepts an ILL5 sentence and interpretes its statements." << endl
		<< "Output of WRITE statements are displayed on the screen." << endl << endl;
	do
	{
		cout << "OBJ-CODE FILE : ";
		cin.getline(str, 20, '\n');
		codeFile.open(str);
	} while (!codeFile);
}

//*******************************************************************//
//*******************************************************************//
//
//						void initMnemonic(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::initMnemonic(void)
{
	strcpy_s(mnemonic[add], "ADD");
	strcpy_s(mnemonic[sub], "SUB");
	strcpy_s(mnemonic[mul], "MUL");
	strcpy_s(mnemonic[dvd], "DVD");
	strcpy_s(mnemonic[ldi], "LDI");
	strcpy_s(mnemonic[lda], "LDA");
	strcpy_s(mnemonic[ldv], "LDV");
	strcpy_s(mnemonic[prc], "PRC");
	strcpy_s(mnemonic[prs], "PRS");
	strcpy_s(mnemonic[nln], "NLN");
	strcpy_s(mnemonic[prn], "PRN");
	strcpy_s(mnemonic[hlt], "HLT");
	strcpy_s(mnemonic[sto], "STO");
	strcpy_s(mnemonic[inc], "INT");
	strcpy_s(mnemonic[eql], "EQL");
	strcpy_s(mnemonic[neq], "NEQ");
	strcpy_s(mnemonic[lss], "LSS");
	strcpy_s(mnemonic[leq], "LEQ");
	strcpy_s(mnemonic[gtr], "GTR");
	strcpy_s(mnemonic[geq], "GEQ");
	strcpy_s(mnemonic[jmp], "JMP");
	strcpy_s(mnemonic[jmz], "JMZ");
	strcpy_s(mnemonic[nul], "NUL");
}

/* ----------------------------------------- the Code Loader -------------------------------------------*/

//*******************************************************************//
//*******************************************************************//
//
//						void ReadLn(istream &istr)
//
//*******************************************************************//
//*******************************************************************//
void ReadLn(istream &istr)
{
	// discard current line in the stream
	char ch;
	istr.get(ch);
	while (ch != '\n') istr.get(ch);
	istr.get(ch); // eat the nwln char
}

//*******************************************************************//
//*******************************************************************//
//
//						void Eoln(istream &istr)
//
//*******************************************************************//
//*******************************************************************//
int Eoln(istream &istr)
{
	// is the rest of the line empty?
	char ch;
	while ((ch = istr.peek()) == ' ') istr.get(ch);
	if (ch == '\n')
		return true;
	else
		return false;
}

//*******************************************************************//
//*******************************************************************//
//
//						void upperCase(char &ch)
//
//*******************************************************************//
//*******************************************************************//
void upperCase(char &ch)
{
	if (ch >= 'a' && ch <= 'z') { ch = ch - 'a' + 'A'; }
}

//*******************************************************************//
//*******************************************************************//
//
//						int isLetter(char ch)
//
//*******************************************************************//
//*******************************************************************//
int isLetter(char ch)
{
	if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))
		return true;
	else
		return false;
}

//*******************************************************************//
//*******************************************************************//
//
//						void skipLabel(char &ch)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::skipLabel(char &ch)
{
	do
	{
		codeFile.get(ch);
	} while (!codeFile.eof() && isLetter(ch) == false);
}

//*******************************************************************//
//*******************************************************************//
//
//						void loadCode(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::loadCode(void)
{
	char ch = ' ';
	int i, nextCode = 0;
	shortString thisCode;
	hasErrors = false;
	for (i = 0; i <= codeMax; i++)
	{
		memory.pCode[i].op = nul; // fill the rest w/ invalid op-code
		memory.pCode[i].arg = 0;
	}

	while (!codeFile.eof())
	{
		skipLabel(ch);
		if (!codeFile.eof())
		{
			upperCase(ch);
			thisCode[0] = ch;
			for (int i = 1; i <= 2; ++i)
			{
				codeFile.get(ch);  upperCase(ch);  thisCode[i] = ch;
			}
			thisCode[3] = '\0';

			memory.pCode[nextCode].op = add; // prepare to search op-code
			strcpy_s(mnemonic[nul], thisCode);
			while (strcmp(thisCode, mnemonic[memory.pCode[nextCode].op]) != false)
			{
				// is thisCode an invalid op-code?
				memory.pCode[nextCode].op = opCodes(memory.pCode[nextCode].op + 1);
			}
			if (memory.pCode[nextCode].op == nul)
			{
				cout << "Invalid op-code " << thisCode << " at " << nextCode << endl;
				hasErrors = true;
			}
			if (memory.pCode[nextCode].op == ldi || memory.pCode[nextCode].op == inc || memory.pCode[nextCode].op == lda || memory.pCode[nextCode].op == jmz || memory.pCode[nextCode].op == jmp)
				if (Eoln(codeFile) == true)
				{
					cout << "Missing operand at instr " << nextCode << endl;
					hasErrors = true;
				}
				else
					codeFile >> memory.pCode[nextCode].arg;

			ReadLn(codeFile);
		} // if
		nextCode = (nextCode + 1) % codeMax;
	}

	for (int ii = nextCode; ii <= codeMax; ii++)
	{
		memory.pCode[ii].op = nul; // fill the rest with invalid op-code
	}
} // loadCode

/* ----------------------------------------- Interpreter Engine -------------------------------------------*/

//*******************************************************************//
//*******************************************************************//
//
//						void interpret(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::interpret(void)
{
	initialize();
	do{ nextStep(); } while (reg.ps == running);
	if (reg.ps != finished) postMortem();
}

//*******************************************************************//
//*******************************************************************//
//
//						void initialize(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::initialize(void)
{
	for (int i = 0; i <= stackMax; i++)
	{
		memory.s[i] = 0; // clear stack
		resetStack();
		reg.pc = 0;
		reg.ps = running;
	}
}

//*******************************************************************//
//*******************************************************************//
//
//						void decBy(int i)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::dectBy(int i) // decrement stack pointer, check for underflow
{
	reg.tos = reg.tos - i;
	if (reg.tos < 0) reg.ps = lowchk;
}

//*******************************************************************//
//*******************************************************************//
//
//						void inctBy(int i)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::inctBy(int i) // increment stack pointer, check for overflow
{
	reg.tos = reg.tos + i;
	if (reg.tos > stackMax) reg.ps = stkchk;
}

//*******************************************************************//
//*******************************************************************//
//
//						int stackOkay(void)
//
//*******************************************************************//
//*******************************************************************//
bool interpreter::stackOkay(void) // check that stack pointer has not underflowed
{
	if (reg.tos < 0) reg.ps = lowchk;
	if (reg.ps == running)
		return true;
	else
		return false;
}

//*******************************************************************//
//*******************************************************************//
//
//						void resetStack(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::resetStack(void) { reg.tos = 0; }

//*******************************************************************//
//*******************************************************************//
//
//						void postMortem(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::postMortem(void)
{
	cout << "Error: ";
	switch (reg.ps)
	{
	case stkchk: cout << "Stack overflow"; break;
	case lowchk: cout << "Stack underflow"; break;
	case divchk: cout << "Can't divide by zero"; break;
	case opchk:  cout << "Invalid op-code"; break;
	}
	cout << " at instruction " << (reg.pc - 1) << "." << endl;
}

//*******************************************************************//
//*******************************************************************//
//
//						string generateString(void)
//
//*******************************************************************//
//*******************************************************************//
string interpreter::generateString(void)
{
	string returnString;
	int moveAmount = memory.s[reg.tos];
	dectBy(moveAmount);
	for (int count = 0; count < moveAmount; count++)
	{
		char appendChar = memory.s[reg.tos];
		returnString.append(1, appendChar);
		inctBy(1);
	}
	dectBy(memory.s[reg.tos] + 1);
	return returnString;
}

//*******************************************************************//
//*******************************************************************//
//
//						void nextStep(void)
//
//*******************************************************************//
//*******************************************************************//
void interpreter::nextStep(void)
{
	pInstruction i;
	i = memory.pCode[reg.pc];
	reg.pc = reg.pc + 1; // fetch next p-instruction
	switch (i.op)
	{
	case nul: reg.ps = opchk; break;
	case add: dectBy(1);
		if (reg.ps == running) memory.s[reg.tos] = memory.s[reg.tos] + memory.s[reg.tos + 1]; break;
	case sub: dectBy(1);
		if (reg.ps == running) memory.s[reg.tos] = memory.s[reg.tos] - memory.s[reg.tos + 1]; break;
	case mul: dectBy(1);
		if (reg.ps == running) memory.s[reg.tos] = memory.s[reg.tos] * memory.s[reg.tos + 1]; break;
	case dvd: dectBy(1);
		if (reg.ps == running)
			if (memory.s[reg.tos + 1] == 0) reg.ps = divchk;
			else memory.s[reg.tos] = int(memory.s[reg.tos] / memory.s[reg.tos + 1]);
			break;
	case eql: dectBy(1);
		if (memory.s[reg.tos] == memory.s[reg.tos + 1])
			memory.s[reg.tos] = 1;
		else
			memory.s[reg.tos] = 0;
		break;
	case neq: dectBy(1);
		if (memory.s[reg.tos] != memory.s[reg.tos + 1])
			memory.s[reg.tos] = 1;
		else
			memory.s[reg.tos] = 0;
		break;
	case gtr: dectBy(1);
		if (memory.s[reg.tos] > memory.s[reg.tos + 1])
			memory.s[reg.tos] = 1;
		else
			memory.s[reg.tos] = 0;
		break;
	case geq: dectBy(1);
		if (memory.s[reg.tos] >= memory.s[reg.tos + 1])
			memory.s[reg.tos] = 1;
		else
			memory.s[reg.tos] = 0;
		break;
	case lss: dectBy(1);
		if (memory.s[reg.tos] < memory.s[reg.tos + 1])
			memory.s[reg.tos] = 1;
		else
			memory.s[reg.tos] = 0;
		break;
	case leq: dectBy(1);
		if (memory.s[reg.tos] <= memory.s[reg.tos + 1])
			memory.s[reg.tos] = 1;
		else
			memory.s[reg.tos] = 0;
		break;
	case ldi: case lda: inctBy(1);
		if (reg.ps == running) memory.s[reg.tos] = i.arg; break;
	case ldv:
		if (reg.ps == running) memory.s[reg.tos] = memory.s[memory.s[reg.tos]]; break;
	case sto: dectBy(1);
		if (reg.ps == running) memory.s[memory.s[reg.tos]] = memory.s[reg.tos + 1];
		dectBy(1);  break;
	case inc: inctBy(i.arg); break;
	case jmp:
		int jmpLocation;
		jmpLocation = i.arg;
		if (jmpLocation > reg.pc)
			while (reg.pc != jmpLocation)
				reg.pc = reg.pc + 1;
		if (jmpLocation < reg.pc)
			while (reg.pc != jmpLocation)
				reg.pc = reg.pc - 1;
		break;
	case jmz:
		if (memory.s[reg.tos] == 0)
		{
			int jmzLocation = i.arg;
			if (jmzLocation > reg.pc)
				while (reg.pc != jmzLocation)
					reg.pc = reg.pc + 1;
			if (jmzLocation < reg.pc)
				while (reg.pc != jmzLocation)
					reg.pc = reg.pc - 1;
		}
		dectBy(1);
		break;
	case prn:
		if (stackOkay() == true) cout << memory.s[reg.tos];
		dectBy(1);
		break;
	case prs:
		if (stackOkay() == true) cout << generateString(); break;
	case prc:
		if (stackOkay() == true)
		{
			char printChar = memory.s[reg.tos];
			cout << printChar;
			dectBy(1);
		}
		break;
	case nln:
		if (stackOkay() == true)
			cout << endl;
		break;
	case hlt: reg.ps = finished; break;
	}
} // nextStep

/*==============================================================================*/

void main() { interpreter myInterpreter; cin.get(); } // construct an interpreter!